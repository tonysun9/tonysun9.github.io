<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>An Intro to Real-Time Machine Learning | Tony Sun</title> <meta name="author" content="Tony Sun"> <meta name="description" content="Preparing features for prediction"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%92%A9&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://tonysun9.github.io/blog/2023/intro-rtml/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Tony Sun</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">An Intro to Real-Time Machine Learning</h1> <h2 class="post-subtitle">Preparing Features for Prediction</h2> <p class="post-meta">August 2023</p> </header> <article class="post-content"> <div id="markdown-content"> <p>I’ve noticed a trend in the data processing world to move from processing data in batches to processing data continuously in a stream [1]. Although there are new challenges associated with stream processing [2], teams make the transition to get real-time insights and make real-time decisions. This, in turn, can lead to a better user experience and create a competitive advantage.</p> <p>Netflix is a premier example of a company that has taken the leap towards real-time data infrastructure [3, 4]. This has enabled Netflix to improve their user experience in a variety of ways, ranging from improving recommendations on the “Trending Now” home screen to quickly resolving playback issues, from rapidly testing changes in production to minimizing downtime of the Netflix service [5, 6, 7, 8].</p> <p>Meanwhile, the field of machine learning has also grown tremendously in the past decade. Machine learning models have become integral to the services offered by companies in a host of domains, including autonomous driving, dynamic pricing, and fraud detection. However, there are many engineering challenges to deploying these models effectively.</p> <p>This post resides at the intersection of these two fields: real-time data infrastructure and machine learning [9,10]. This post is primarily intended for data scientists and machine learning engineers who want to gain a better understanding of the <strong>underlying data pipelines to serve features for real-time prediction</strong>. In particular, this post addresses three main questions:</p> <ol> <li>What is real-time machine learning?</li> <li>Why is real-time machine learning important?</li> <li>How do we prepare features to be readily available for querying in a real-time prediction service?</li> </ol> <h2 id="what-is-real-time-machine-learning">What is real-time machine learning?</h2> <p>The critical component of <em>real-time machine learning</em> is the use of machine learning models to <strong>make predictions in real-time</strong>. Specifically, a prediction is made through a <em>synchronous request</em> and a response is expected to return immediately – on the order of hundreds of milliseconds, oftentimes less.</p> <p>Contrast this to making predictions in batch, in which predictions are made on a large volume of data points all at once [11, *]. Predictions are made via an <em>asynchronous batch job</em>. I have heard the term <em>batch machine learning</em> to describe this concept, although it doesn’t appear to be highly prevalent [12].</p> <p>Let’s work with a fraud detection example. In this example, a consumer purchases a laptop online. The credit card network, say Visa, tries to detect whether the transaction is fraudulent or not.</p> <p>Using the real-time machine learning paradigm, a prediction is made in <em>real-time</em>. That might look like the following:</p> <ol> <li>The transaction is an <em>event</em> relayed by a <em>message broker</em> that in turn triggers a <em>request</em> to a <em>prediction service</em> that predicts whether the transaction is fraudulent or not.</li> <li>The prediction service is responsible for fetching the relevant features from the <em>feature store</em> and passing those features along to the <em>model endpoint</em> to make a prediction.</li> <li>If the transaction is believed to be fraudulent, the transaction is flagged as such and prevented from going through.</li> </ol> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/blog/2023/intro-rtml/rt-prediction-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/blog/2023/intro-rtml/rt-prediction-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/blog/2023/intro-rtml/rt-prediction-1400.webp"></source> <img src="/blog/2023/intro-rtml/rt-prediction.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>Using the batch machine learning paradigm, predictions are made in <em>batch</em>. Here’s how that might happen:</p> <ol> <li>During the day, transactions are accumulated into a <em>data warehouse</em>.</li> <li>Periodically, say nightly, an <em>orchestrator</em> kicks off an asynchronous batch job that processes the data. The job involves extracting raw data from the data warehouse, cleaning and transforming that data into features, and making predictions in <em>batch</em> [13].</li> <li>For transactions deemed fraudulent, an alert is raised.</li> </ol> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/blog/2023/intro-rtml/batch-prediction-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/blog/2023/intro-rtml/batch-prediction-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/blog/2023/intro-rtml/batch-prediction-1400.webp"></source> <img src="/blog/2023/intro-rtml/batch-prediction.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <h3 id="terminology">Terminology</h3> <p>In case any of the terms around real-time prediction [14] were confusing, let’s take a moment to clarify some terms in the context of machine learning operations:</p> <h4 id="real-time-prediction--online-prediction-batch-prediction--offline-prediction">real-time prediction = online prediction; batch prediction = offline prediction</h4> <p>The terms “real-time prediction” and “online prediction” are often used synonymously. Similarly, “batch prediction” and “offline prediction” are interchangeable. I have a preference for the terms “real-time” and “batch” over their counterparts, “online” and “offline,” respectively, from the clarity they provide on the nature of the prediction process [*].</p> <h4 id="real-time-prediction-terms">Real-time Prediction Terms</h4> <p>Event Broker: kind of like a post office for software, accepting messages (events) from one part of a system (producers) and delivering them to other parts of the system (consumers) [*].</p> <p>Feature store: a database that serves as a central repository for storing, managing, and serving machine learning features [*].</p> <p>Prediction Service: the infrastructure and related services set up to use a machine learning model for making predictions [*]. In our example, this includes querying the feature store and passing those features to a model endpoint.</p> <p>Model Endpoint: the network interface exposed by a deployed machine learning model, typically via a RESTful API, to receive and respond to prediction requests [*].</p> <h2 id="why-is-real-time-machine-learning-important">Why is real-time machine learning important?</h2> <p>Before we dive into preparing features for real-time prediction, let’s first understand why real-time machine learning is important.</p> <p>Real-time machine learning is powerful for its ability to help <strong>get real-time insights and make real-time decisions.</strong> This information and these choices are critical for some applications, improve user experience in others, and enable proactive responses in yet others.</p> <p>In our example, flagging a transaction as fraudulent in real-time and preventing that transaction from going through is far more effective than initiating the chargeback process, which requires multiple steps of verification, dispute, and potential reversal [*]. Given that fraud detection is a $385 billion industry [15], any reduction in financial loss can be of significant magnitude.</p> <p>Here’s a brief and by no means comprehensive list of some applications that benefit from real-time machine learning:</p> <ul> <li>Anomaly detection for fraud detection, network security, healthcare monitoring, and quality control.</li> <li>Personalized recommendations for marketing, e-commerce, and media and entertainment.</li> <li>Real-time decision making for autonomous driving, high-frequency trading, and robotics.</li> </ul> <p>And if you’re reading this post, I’m sure you have a use case in mind that can benefit from real-time machine learning as well.</p> <h2 id="how-do-we-prepare-features-to-be-readily-available-for-querying-in-a-real-time-machine-learning-pipeline">How do we prepare features to be readily available for querying in a real-time machine learning pipeline?</h2> <p>Earlier, we characterized a real-time prediction service as a system responsible for <strong>querying for the relevant features from a feature store</strong> and passing those features along to a model endpoint to perform prediction.</p> <p>The purpose of the feature store is to <strong>reduce the latency of a prediction request</strong>. By pre-computing feature values in advance, we save time that would otherwise be spent calculating these values during the prediction request. This not only makes our prediction service more efficient but also enables us to handle higher volumes of requests in a scalable way [*].</p> <p>We now turn our focus to the feature preparation component – namely, to <strong>populate the feature store</strong> with pre-computed features such that they can be readily queried when it comes time for real-time prediction.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/blog/2023/intro-rtml/feature-store-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/blog/2023/intro-rtml/feature-store-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/blog/2023/intro-rtml/feature-store-1400.webp"></source> <img src="/blog/2023/intro-rtml/feature-store.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>The engineering challenges around preparing features for real-time prediction depend on the types of features we’ll be working with. To break down this question, we’ll first give an example of what a feature store might look like, then cover the different types of features, and finally discuss how to populate them into our feature store.</p> <h3 id="feature-store">Feature Store</h3> <p>Feature stores can vary in complexity, ranging from a simple repository of pre-computed features to a much more intricate system responsible for feature versioning, data quality monitoring, access control, and more.</p> <p>For our purposes, we will use a simple <strong>key-value store</strong> as our feature store [16]. In our feature store, each key-value pair corresponds to a <strong>computed feature value</strong>.</p> <p>Here’s what a key-value pair might look like: the key is a concatenation of the feature name and its corresponding entity value(s). The value represents a computed feature value.</p> <p>For example, if the feature is the average transaction amount over the past 3 months, “credit card number” would be a natural choice for the entity of this feature. An example of an entity value could be “1234.” The computed feature value could be $36.08.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/blog/2023/intro-rtml/entity-key-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/blog/2023/intro-rtml/entity-key-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/blog/2023/intro-rtml/entity-key-1400.webp"></source> <img src="/blog/2023/intro-rtml/entity-key.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>The <em>entity</em> of a feature relates to how the feature is being computed. One way to think about this is “<strong>feature</strong> of <em>entity</em>.” For example, I might care about the <strong>average transaction amount</strong> of a <em>credit card number</em>, or I might want to know the <strong>age</strong> of a <em>customer</em>. An <em>entity value</em> represents the specific instance of an entity.</p> <p>Naturally, a feature can also have more than one entity. For example, the feature “average transaction amount with a given merchant over the past 3 months” would use “credit card number” and “merchant_id” as its entities.</p> <h3 id="real-time-prediction">Real-time Prediction</h3> <p>Real-time prediction involves “querying for the relevant features from a feature store**.” **We just went over “feature store;” now, let’s clarify what we mean by “querying for the relevant features.”</p> <ol> <li> <strong>What</strong> are the features we should query for?</li> <li> <strong>How</strong> do we query for those features from the feature store?</li> </ol> <h4 id="what-are-the-features-we-should-query-for">What are the features we should query for?</h4> <p>The features we should query for naturally <strong>depend on the model</strong> we intend to use for prediction. Since the model is trained using a certain set of features, it requires those same features to do prediction.</p> <p>For the sake of our example, let’s say our model was trained with just the following four features (represented as feature name: entity; can be helpful to think “feature <em>of</em> entity”):</p> <ol> <li>log(transaction amount): transaction_id</li> <li>customer_age: customer_id</li> <li># of transactions in the past 10 minutes: credit card number</li> <li>average transaction amount in the past 3 months: credit card number</li> </ol> <h4 id="how-do-we-query-for-those-features-from-the-feature-store">How do we query for those features from the feature store?</h4> <p>Our goal is to query the feature store (a key-value store in our example) for the features our model requires. For each of those features, we need to construct the corresponding key. In our example, we use a combination of the feature name and the feature’s entity value. The <strong>entity value will depend on the information observed in the event</strong> on which we aim to do prediction.</p> <p>Say our transaction event looks as follows (represented as field name: value):</p> <ul> <li>transaction_id: a0d8</li> <li>credit_card_num: 1234</li> <li>customer_id: 9092</li> <li>…</li> <li>transaction_amount: 999.99</li> </ul> <p>For the feature “customer_age,” we can query our feature store for the value corresponding to the key “customer_age_9092,” indicating the age of the customer with customer_id 9092. We do this for each feature.</p> <p>The exception are features that can be computed using just information in the event. These features, such as “log(transaction amount)”, are computed separately in real-time and do not needed to written to / read from the feature store. We’ll drill in more in the following sections.</p> <h3 id="types-of-features">Types of Features</h3> <p>The most common way to categorize features is in terms of discrete (categorical) vs continuous (numerical). However, as a post focused on the engineering challenges of making features readily available for real-time prediction, I’d like to propose two new axes of categorization:</p> <ol> <li> <strong>Stateless vs Stateful</strong> <ol> <li> <em>Stateless features</em> can be computed based on the information available in the current event alone. They don’t depend on any previous events.</li> <li> <em>Stateful features</em> require knowledge about previous events or instances. They maintain a “state” from the past [17].</li> </ol> </li> <li> <strong>Slow-changing vs Fast-changing</strong> <ol> <li> <em>Fast-changing features</em> are features that can change rapidly, even between events that are close together in time [*].</li> <li> <em>Slow-changing features</em> are features that don’t change, or change very slowly over time [*].</li> </ol> </li> </ol> <p>It may be tempting to think of fast-changing as stateless and slow-changing as stateful. However, this is not necessarily the case. Let’s categorize our previous feature examples:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/blog/2023/intro-rtml/feature-types-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/blog/2023/intro-rtml/feature-types-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/blog/2023/intro-rtml/feature-types-1400.webp"></source> <img src="/blog/2023/intro-rtml/feature-types.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <ol> <li>log(transaction amount): a <strong>stateless and fast-changing</strong> feature. Computing the log of the transaction amount changes with each transaction and requires only the information present in the current event.</li> <li>customer_age: a <strong>stateless and slow-changing</strong> feature. A customer’s age increments slowly. Additionally, it does not depend on any prior events.</li> <li># of transactions in the past 10 minutes: a <strong>stateful and fast-changing</strong> feature. To compute this feature, we need to maintain a count of the customer’s transactions in the last 10 minutes. Furthermore, the count can rapidly change with every new transaction or when transactions fall out of the 10-minute window.</li> <li>average transaction amount in the past 3 months: a <strong>stateful and slow-changing</strong> feature. Computing this feature requires a record of the customer’s transaction amounts over the past 3 months. Although new transactions and the passing of time may affect this feature, the feature value will likely change slowly.</li> </ol> <h3 id="populating-the-feature-store">Populating the Feature Store</h3> <p>Each of the four types of features requires a different method of computation. We go over each feature type below:</p> <h4 id="stateless-and-fast-changing">Stateless and Fast-Changing</h4> <p>Computing stateless and fast-changing features requires us to <strong>process each event on its own</strong>. For our “log(transaction amount)” feature, this involves extracting the transaction amount from the event and running a function that computes the log of a number.</p> <p>This can be done through an <em>event-driven compute service</em> such as AWS Lambda.</p> <p>Stateless and fast-changing features are also known as <em>real-time</em> _feature_s because they are computed on-the-fly, in real-time.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/blog/2023/intro-rtml/stateless-fc-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/blog/2023/intro-rtml/stateless-fc-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/blog/2023/intro-rtml/stateless-fc-1400.webp"></source> <img src="/blog/2023/intro-rtml/stateless-fc.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>Something unique about stateless and fast-changing features is that they are not fetched from the feature store, which only stores pre-computed values. This also means that the entity is not relevant for these features.</p> <h4 id="stateless-and-slow-changing">Stateless and Slow-Changing</h4> <p>Because stateless and slow-changing features are slow-changing by definition, it makes sense to pre-compute these features and load them in the feature store well ahead of prediction time. This can be done through a <strong>batch engine</strong> such as Apache Spark.</p> <p>This typically involves querying for some data in an external warehouse or something similar. This may involve some data cleaning and transformation, although that may not be necessary, especially for stateless features. For our “age” feature, we would just need to query for the age of each customer_id and store those results in the feature store.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/blog/2023/intro-rtml/stateless-sc-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/blog/2023/intro-rtml/stateless-sc-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/blog/2023/intro-rtml/stateless-sc-1400.webp"></source> <img src="/blog/2023/intro-rtml/stateless-sc.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>Stateless and slow-changing features can also be considered <em>batch</em> features because they are typically computed in a batch process. The pipeline might look similar to our batch prediction pipeline earlier, except we stop before the model prediction part and instead store the transformed values (features) into our feature store.</p> <p>Using a batch engine like Apache Spark offers benefits in terms of robustness and efficiency. Spark is fault-tolerant which means it can recover from failures and errors without losing data or functionality. Spark jobs can also scale horizontally, ensuring timely processing even as the size of the data grows [*].</p> <p>However, one downside of pre-computing features in a batch process is the need for <strong>excess computation and storage</strong>. Because we don’t know which entity values will be encountered at runtime, we would need to compute the feature values for all possible entity values. Depending on the traffic pattern, many computed feature values may go unused, wasting computation and space in the feature store.</p> <p>In our example, we would need to load the age of <strong>all</strong> customers into our feature store. However, if the cardinality of our feature is high (there are many unique customer IDs), doing so may not be practical.</p> <p>An alternative would be to query for the feature value at runtime, reducing the number of features stored in the feature store at the cost of increasing prediction latency. A practical solution could be to <strong>pre-compute features for the most frequently used entity values</strong> and query for the feature value for less frequently used entity values.</p> <h4 id="stateful-and-fast-changing">Stateful and Fast-Changing</h4> <p>Computing stateful and fast-changing features requires a <strong>stream processing engine</strong>, such as Apache Flink.</p> <p>A stream processing engine, like Apache Flink, facilitates real-time data processing of incoming data streams. While batch processing is efficient for processing large, static datasets at once, it’s not designed to handle the dynamic nature of stateful and fast-changing features [*].</p> <p>Windowing is a critical component of stream processing. For our feature “# of transactions in the past 10 minutes,” [18] we would also need to be more precise about when the feature is computed. Here are three different options [19, 20]:</p> <ol> <li>Tumbling window: compute the feature every 10 minutes (same as the window size of the feature).</li> <li>Sliding (hopping) window: specify another duration, less than ten minutes, for how often we want to compute the feature. For example, we might want to compute the feature every minute. This means that the feature is updated more frequently and the computation windows overlap [*]. A sliding window is a more general version of the tumbling window.</li> <li>Per-event: compute the feature for each incoming event.</li> </ol> <p>If stateful and fast-changing features are computed with a tumbling or sliding window, they can also be considered <em>near real-time features</em>, because they are computed shortly before prediction time. However, if the feature is computed at prediction time, as when using over aggregation, this feature would be considered a <em>real-time</em> feature.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/blog/2023/intro-rtml/stateful-fc-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/blog/2023/intro-rtml/stateful-fc-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/blog/2023/intro-rtml/stateful-fc-1400.webp"></source> <img src="/blog/2023/intro-rtml/stateful-fc.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>Computed to batch processing, stream processing can be more complex due to challenges around event time skew, state management, and unbounded data, to name a few [21].</p> <p>An alternative is <em>micro-batch</em> processing (basically batch processing in small, discrete chunks), though it may not be a practical one. Here are a few reasons why:</p> <ul> <li> <strong>State Management</strong>: Managing state across batches can be a difficult task, especially in a distributed environment.</li> <li> <strong>Resource Consumption</strong>: Micro-batch processing often has higher resource overhead than stream processing because of the constant creation and destruction of small job [*]. Additionally, if multiple batches include similar data or require similar processing steps, maintaining a long-running stateful job with stream processing may actually be more resource efficient.</li> <li> <strong>Latency</strong>: While micro-batch processing can reduce latency compared to traditional batch processing, it still can’t match the low latency provided by true stream processing engines like Apache Flink [*]. <ul> <li>For instance, trying to perform over aggregation with micro-batch processing would require spinning up a new job for each event, which is not really feasible for real-time prediction.</li> </ul> </li> </ul> <h4 id="stateful-and-slow-changing">Stateful and Slow-Changing</h4> <p>Stateful and slow-changing features have the most flexibility in terms of how they are computed.</p> <p>Since these features are slow-changing, it might make sense to compute them in batch. However, that isn’t to say that these features can’t be computed in near real-time or even real-time with a stream processing engine as well.</p> <p>One factor to consider is the <strong><em>freshness</em> requirements of the feature</strong>. If a slightly <em>stale</em> and outdated value for the feature is acceptable, then batch processing could be sufficient. “Staleness” in this context refers to when the feature was computed relative to the event time. The greater the gap, the more stale the feature value is.</p> <p>Staleness matters for two reasons:</p> <ol> <li> <strong>Exclusion of recent data</strong>. If recent information is important to how the feature is computed and ultimately model performance, it may be critical to have fresh data.</li> <li> <strong>Train-prediction inconsistency.</strong> If the model was trained with features computed at the time of event but uses stale features at the time of prediction, this can lead to worse model performance. Ensuring train-prediction consistency is a nuanced point and will be explored more in-depth in the next post.</li> </ol> <p>Another consideration is how much repetitive computation will be performed during each batch. For example, if my feature is computed on data from the past three months, re-running a batch job to compute that feature every night can be wasteful [22]. In such a scenario, a stateful, long-running streaming job can actually lower costs.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/blog/2023/intro-rtml/batch-processing-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/blog/2023/intro-rtml/batch-processing-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/blog/2023/intro-rtml/batch-processing-1400.webp"></source> <img src="/blog/2023/intro-rtml/batch-processing.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <h4 id="derived-features">Derived Features</h4> <p>Derived features are <strong>features that build upon other features</strong>. For example, say that in my data exploration process, I find the feature “Z-score of transaction amount” to be predictive of fraud. After all, a transaction amount 3 standard deviations above the mean would be quite alarming.</p> <p>How the derived feature is computed naturally depends on how the underlying features are computed. In our example, computing the mean and standard deviation of the average transaction amount in the past three months can be considered to be stateful and slow-changing features. We could compute these two features with either a batch or streaming engine. Once in the feature store, we can use an event’s transaction amount and combine it with the mean and standard deviation in a lambda function to compute the Z-score.</p> <h4 id="summary">Summary</h4> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/blog/2023/intro-rtml/feature-types-summary-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/blog/2023/intro-rtml/feature-types-summary-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/blog/2023/intro-rtml/feature-types-summary-1400.webp"></source> <img src="/blog/2023/intro-rtml/feature-types-summary.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>Put it all together, and this is a more complete depiction of real-time machine learning pipeline:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/blog/2023/intro-rtml/rt-prediction-full-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/blog/2023/intro-rtml/rt-prediction-full-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/blog/2023/intro-rtml/rt-prediction-full-1400.webp"></source> <img src="/blog/2023/intro-rtml/rt-prediction-full.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <h2 id="conclusion">Conclusion</h2> <p>I hope you learned something about real-time machine learning from this post. We started with a high-level overview before diving into stateless vs stateful and fast-changing vs slow-changing features. For each of the four types of features we discussed, we gave an example of how they might be computed.</p> <p>However, preparing features to be used for real-time prediction is only half the story. We also need to go over how to prepare features for training the right way, to avoid potential problems like train-prediction inconsistency. This will be the topic of my next post, so stay tuned.</p> <p>In the meantime, I’m always learning more about real-time machine learning. If this post resonated with you, I’d love to hear from you. I work at Claypot AI, where we’re building a real-time machine learning platform.</p> <hr> <h2 id="acknowledgments">Acknowledgments</h2> <p>Thanks to Zhenzhong Xu and Chip Huyen for reviewing early drafts of this post.</p> <hr> <h2 id="appendix">Appendix</h2> <p>* The asterisk represents text that I’ve added with the help of a LLM such as GPT or Bard.</p> <p>[1] A Google Trends <a href="https://trends.google.com/trends/explore/TIMESERIES/1691956800?hl=en-US&amp;tz=420&amp;date=2013-01-01+2023-01-01&amp;geo=US&amp;hl=en&amp;q=stream+processing,batch+processing&amp;sni=3" rel="external nofollow noopener" target="_blank">graph</a> of web searches for stream processing (red) vs batch processing (blue) in the past 10 years. At the moment, batch processing is still more prevalent than stream processing, although the gap between the two has shortened over time.</p> <p>[2] Some new challenges around stream processing include the need to handle unbounded data streams, out-of-order data, and stateful computation, to name a few.</p> <p>[3] <a href="https://zhenzhongxu.com/the-four-innovation-phases-of-netflixs-trillions-scale-real-time-data-infrastructure-2370938d7f01" rel="external nofollow noopener" target="_blank">The Four Innovation Phases of Netflix’s Trillions Scale Real-time Data Infrastructure</a></p> <p>[4] <a href="https://netflixtechblog.com/tagged/stream-processing" rel="external nofollow noopener" target="_blank">Netflix Tech Blog: Stream Processing</a></p> <p>[5] <a href="https://netflixtechblog.com/whats-trending-on-netflix-f00b4b037f61" rel="external nofollow noopener" target="_blank">What’s trending on Netflix?</a></p> <p>[6] <a href="https://netflixtechblog.com/stream-processing-with-mantis-78af913f51a6" rel="external nofollow noopener" target="_blank">Stream-processing with Mantis</a></p> <p>[7] <a href="https://netflixtechblog.com/keystone-real-time-stream-processing-platform-a3ee651812a" rel="external nofollow noopener" target="_blank">Keystone Real-time Stream Processing Platform</a></p> <p>[8] <a href="https://netflixtechblog.com/open-sourcing-mantis-a-platform-for-building-cost-effective-realtime-operations-focused-5b8ff387813a" rel="external nofollow noopener" target="_blank">Open Sourcing Mantis: A Platform For Building Cost-Effective, Realtime, Operations-Focused Applications</a></p> <p>[9] <a href="https://huyenchip.com/2020/12/27/real-time-machine-learning.html" rel="external nofollow noopener" target="_blank">Machine learning is going real-time</a></p> <p>[10] <a href="https://www.tecton.ai/blog/what-is-real-time-machine-learning/" rel="external nofollow noopener" target="_blank">What Is Real-Time Machine Learning?</a></p> <p>[11] <a href="https://docs.aws.amazon.com/machine-learning/latest/dg/about-batch-predictions.html" rel="external nofollow noopener" target="_blank">Batch predictions</a></p> <p>[12] A quick search online for the term “batch machine learning” leads to more results around the <em>batch size</em> for model training as opposed to batch prediction.</p> <p>[13] <a href="https://github.com/jacopotagliabue/you-dont-need-a-bigger-boat" rel="external nofollow noopener" target="_blank">You Don’t Need a Bigger Boat</a> is also a good resource.</p> <p>[14] I’ve seen “model prediction” and “model inference” used interchangeably. Both refer to “the process of running data points into a machine learning model to calculate an output such as a single numerical score” [<a href="https://cloud.google.com/bigquery/docs/inference-overview" rel="external nofollow noopener" target="_blank">Model inference overview</a>] . I personally prefer to use the term “model prediction.”</p> <p>From a statistical perspective, inference and prediction actually mean slightly different things. Inference refers to the “study of the impact of factors on the outcome.” For example, inference aims to answer questions such as “What is the effect of age on surviving the Titanic disaster?”, whereas prediction aims to answer questions such as “Given some information on a Titanic passenger, you want to predict whether they live or not and be correct as often as possible” [<a href="https://stats.stackexchange.com/a/301158" rel="external nofollow noopener" target="_blank">What is the difference between prediction and inference?</a>, An Introduction to Statistical Learning].</p> <p>[15] <a href="https://www.ibm.com/downloads/cas/DOXY3Q94" rel="external nofollow noopener" target="_blank">Operationalizing Fraud Prevention on IBM z16</a></p> <p>[16] <a href="https://doordash.engineering/2020/11/19/building-a-gigascale-ml-feature-store-with-redis/" rel="external nofollow noopener" target="_blank">Building a Scalable ML Feature Store with Redis</a></p> <p>[17] For stateful features, the entity corresponds to the field used by the GROUP BY clause if we were to compute the feature at a given point in time:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">SELECT</span> <span class="n">credit_card_num</span><span class="p">,</span> 

       <span class="k">AVG</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span> <span class="k">AS</span> <span class="n">avg_transaction_amount</span>

<span class="k">FROM</span> <span class="n">transactions</span>

<span class="k">WHERE</span> <span class="n">transaction_date</span> <span class="o">&gt;=</span> <span class="n">DATE_SUB</span><span class="p">(</span><span class="n">CURDATE</span><span class="p">(),</span> <span class="n">INTERVAL</span> <span class="mi">3</span> <span class="k">MONTH</span><span class="p">)</span>

<span class="k">GROUP</span> <span class="k">BY</span> <span class="o">**</span><span class="n">credit_card_num</span><span class="o">**</span><span class="p">;</span>

</code></pre></div></div> <p>[18] A session is another type of window, but the beginning and end depend on user behavior.</p> <p>[19] <a href="https://nightlies.apache.org/flink/flink-docs-release-1.15/docs/dev/table/sql/queries/window-tvf/#tumble" rel="external nofollow noopener" target="_blank">Windowing TVF</a></p> <p>[20] <a href="https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/dev/table/sql/queries/over-agg/" rel="external nofollow noopener" target="_blank">Over Aggregation</a></p> <p>[21] <a href="https://www.oreilly.com/radar/the-world-beyond-batch-streaming-101/" rel="external nofollow noopener" target="_blank">Streaming 101: The world beyond batch</a></p> <p>[22] The idea for the diagram is stolen shamelessly from Chip’s <a href="https://huyenchip.com/2022/01/02/real-time-machine-learning-challenges-and-solutions.html" rel="external nofollow noopener" target="_blank">continual training</a> graphic.</p> </div> </article> </div> </div> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>